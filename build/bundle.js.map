{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 93a3ea5148ab2772364d","webpack:///./app/common.js","webpack:///./app/util.js","webpack:///./app/dom.js","webpack:///./app/constants.js","webpack:///./app/game.js","webpack:///./app/render.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_interopRequireDefault","update","dt","n","car","carW","sprite","spriteW","playerSegment","findSegment","position","playerZ","playerW","_constants","SPRITES","PLAYER_STRAIGHT","w","SCALE","speedPercent","speed","maxSpeed","dx","startPosition","updateCars","Util","increase","trackLength","keyLeft","playerX","keyRight","curve","centrifugal","keyFaster","accelerate","accel","keySlower","breaking","decel","offRoadLimit","offRoadDecel","sprites","length","source","overlap","offset","p1","world","z","cars","limit","skyOffset","skySpeed","segmentLength","hillOffset","hillSpeed","treeOffset","treeSpeed","currentLapTime","updateHud","Math","round","formatTime","oldSegment","newSegment","updateCarOffset","percent","percentRemaining","index","indexOf","splice","push","carSegment","i","j","dir","segment","otherCar","otherCarW","lookahead","drawDistance","segments","value","hud","_dom2","set","dom","minutes","floor","seconds","tenths","render","baseSegment","basePercent","playerPercent","playerY","interpolate","y","p2","maxy","height","x","ctx","clearRect","width","_render2","background","BACKGROUND","SKY","resolution","HILLS","TREES","spriteScale","spriteX","spriteY","looped","fog","exponentialFog","fogDensity","clip","project","roadWidth","cameraHeight","cameraDepth","camera","screen","lanes","color","scale","player","lastY","addSegment","rumbleLength","COLORS","DARK","LIGHT","addRoad","enter","hold","leave","startY","endY","toInt","total","easeIn","easeInOut","addStraight","num","ROAD","LENGTH","MEDIUM","addHill","HILL","addCurve","CURVE","NONE","addLowRollingHills","SHORT","LOW","EASY","addSCurves","addBumps","addDownhillToEnd","resetRoad","LONG","HIGH","resetSprites","resetCars","START","FINISH","totalCars","random","randomChoice","CARS","SEMI","reset","options","canvas","fieldOfView","tan","PI","refreshTweakUI","get","selectedIndex","innerHTML","_render","_game","_game2","_util","_dom","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","callback","element","setTimeout","fps","step","getContext","gameState","current_lap_time","HARD","newGame","run","images","keys","KEY","LEFT","A","mode","action","RIGHT","D","UP","W","DOWN","S","ready","console","log","defineProperty","timestamp","Date","getTime","def","parseInt","isNaN","toFloat","parseFloat","min","max","randomInt","v","a","b","pow","easeOut","cos","distance","density","E","start","increment","result","cameraX","cameraY","cameraZ","x1","w1","x2","w2","half","min1","max1","min2","max2","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","Dom","this","storage","localStorage","HTMLElement","document","getElementById","html","ele","type","fn","capture","addEventListener","removeEventListener","style","display","ev","blur","name","toggleClassName","on","classes","className","split","join","TREE","FOG","road","grass","rumble","lane","h","PALM_TREE","BILLBOARD08","TREE1","DEAD_TREE1","BILLBOARD09","BOULDER3","COLUMN","BILLBOARD01","BILLBOARD06","BILLBOARD05","BILLBOARD07","BOULDER2","TREE2","BILLBOARD04","DEAD_TREE2","BOULDER1","BUSH1","CACTUS","BUSH2","BILLBOARD03","BILLBOARD02","STUMP","TRUCK","CAR03","CAR02","CAR04","CAR01","PLAYER_UPHILL_LEFT","PLAYER_UPHILL_STRAIGHT","PLAYER_UPHILL_RIGHT","PLAYER_LEFT","PLAYER_RIGHT","BILLBOARDS","PLANTS","Game","_this","loadImages","frame","now","last","gdt","setKeyListener","names","preloadImage","path","Promise","resolve","reject","image","Image","onload","onerror","src","all","map","url","imgUrl","then","arr","catch","err","onkey","keyCode","k","Render","y1","y2","x3","y3","x4","y4","fillStyle","beginPath","moveTo","lineTo","closePath","fill","lanew1","lanew2","lanex1","lanex2","r1","rumbleWidth","r2","l1","laneMarkerWidth","l2","fillRect","polygon","layer","rotation","imageW","imageH","sourceX","sourceY","sourceW","sourceH","destX","destY","destW","destH","drawImage","offsetX","offsetY","clipY","clipH","steer","updown","bounce","globalAlpha","projectedRoadWidth"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _render = __webpack_require__(5);\n\t\n\tvar _render2 = _interopRequireDefault(_render);\n\t\n\tvar _game = __webpack_require__(4);\n\t\n\tvar _game2 = _interopRequireDefault(_game);\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar Util = _interopRequireWildcard(_util);\n\t\n\tvar _dom = __webpack_require__(2);\n\t\n\tvar _dom2 = _interopRequireDefault(_dom);\n\t\n\tvar _constants = __webpack_require__(3);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t//=========================================================================\n\t// POLYFILL for requestAnimationFrame\n\t//=========================================================================\n\t\n\tif (!window.requestAnimationFrame) {\n\t  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t  window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {\n\t    window.setTimeout(callback, 1000 / 60);\n\t  };\n\t}\n\t\n\t//=========================================================================\n\t\n\tvar fps = 60; // how many 'update' frames per second\n\tvar step = 1 / fps; // how long is each frame (in seconds)\n\tvar width = 1024; // logical canvas width\n\tvar height = 768; // logical canvas height\n\tvar centrifugal = 0.3; // centrifugal force multiplier when going around curves\n\t// let offRoadDecel   = 0.99;                    // speed multiplier when off road (e.g. you lose 2% speed each update frame)\n\tvar skySpeed = 0.001; // background sky layer scroll speed when going around curve (or up hill)\n\tvar hillSpeed = 0.002; // background hill layer scroll speed when going around curve (or up hill)\n\tvar treeSpeed = 0.003; // background tree layer scroll speed when going around curve (or up hill)\n\tvar skyOffset = 0; // current sky scroll offset\n\tvar hillOffset = 0; // current hill scroll offset\n\tvar treeOffset = 0; // current tree scroll offset\n\tvar segments = []; // array of road segments\n\tvar cars = []; // array of cars on the road\n\t// let stats          = Game.stats('fps');       // mr.doobs FPS counter\n\tvar canvas = _dom2.default.get('canvas'); // our canvas...\n\tvar ctx = canvas.getContext('2d'); // ...and its drawing context\n\tvar GAME_STATES = ['intro', 'players', 'start', 'game', 'gameover'];\n\tvar gameState = 'intro';\n\tvar background = null; // our background image (loaded below)\n\tvar sprites = null; // our spritesheet (loaded below)\n\tvar resolution = null; // scaling factor to provide resolution independence (computed)\n\tvar roadWidth = 2000; // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth\n\tvar segmentLength = 200; // length of a single segment\n\tvar rumbleLength = 3; // number of segments per red/white rumble strip\n\tvar trackLength = null; // z length of entire track (computed)\n\tvar lanes = 3; // number of lanes\n\tvar fieldOfView = 100; // angle (degrees) for field of view\n\tvar cameraHeight = 1000; // z height of camera\n\tvar cameraDepth = null; // z distance camera is from screen (computed)\n\tvar drawDistance = 150; // number of segments to draw\n\tvar playerX = 0; // player x offset from center of road (-1 to 1 to stay independent of roadWidth)\n\tvar playerZ = null; // player relative z distance from camera (computed)\n\tvar fogDensity = 4; // exponential fog density\n\tvar position = 0; // current camera Z position (add playerZ to get player's absolute Z position)\n\tvar maxSpeed = segmentLength / step * 1.5; // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)\n\tvar speed = 0; // current speed\n\tvar accel = maxSpeed / 5; // acceleration rate - tuned until it 'felt' right\n\tvar breaking = -maxSpeed; // deceleration rate when braking\n\tvar decel = -maxSpeed / 5; // 'natural' deceleration rate when neither accelerating, nor braking\n\tvar offRoadDecel = -maxSpeed / 2; // off road deceleration is somewhere in between\n\tvar offRoadLimit = maxSpeed / 4; // limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)\n\tvar totalCars = 200; // total number of cars on the road\n\tvar currentLapTime = 0; // current lap time\n\tvar lastLapTime = null; // last lap time\n\t\n\tvar keyLeft = false;\n\tvar keyRight = false;\n\tvar keyFaster = false;\n\tvar keySlower = false;\n\t\n\tvar hud = {\n\t  speed: { value: null, dom: _dom2.default.get('speed_value') },\n\t  current_lap_time: { value: null, dom: _dom2.default.get('current_lap_time_value') }\n\t};\n\t\n\t//=========================================================================\n\t// UPDATE THE GAME WORLD\n\t//=========================================================================\n\t\n\tfunction update(dt) {\n\t  var n, car, carW, sprite, spriteW;\n\t  var playerSegment = findSegment(position + playerZ);\n\t  var playerW = _constants.SPRITES.PLAYER_STRAIGHT.w * _constants.SPRITES.SCALE;\n\t  var speedPercent = speed / maxSpeed;\n\t  var dx = dt * 2 * speedPercent; // at top speed, should be able to cross from left to right (-1 to 1) in 1 second\n\t  var startPosition = position;\n\t\n\t  updateCars(dt, playerSegment, playerW);\n\t\n\t  position = Util.increase(position, dt * speed, trackLength);\n\t\n\t  if (keyLeft) playerX = playerX - dx;else if (keyRight) playerX = playerX + dx;\n\t\n\t  playerX = playerX - dx * speedPercent * playerSegment.curve * centrifugal;\n\t\n\t  if (keyFaster) speed = Util.accelerate(speed, accel, dt);else if (keySlower) speed = Util.accelerate(speed, breaking, dt);else speed = Util.accelerate(speed, decel, dt);\n\t\n\t  if (playerX < -1 || playerX > 1) {\n\t\n\t    if (speed > offRoadLimit) speed = Util.accelerate(speed, offRoadDecel, dt);\n\t\n\t    for (n = 0; n < playerSegment.sprites.length; n++) {\n\t      sprite = playerSegment.sprites[n];\n\t      spriteW = sprite.source.w * _constants.SPRITES.SCALE;\n\t      if (Util.overlap(playerX, playerW, sprite.offset + spriteW / 2 * (sprite.offset > 0 ? 1 : -1), spriteW)) {\n\t        speed = maxSpeed / 5;\n\t        position = Util.increase(playerSegment.p1.world.z, -playerZ, trackLength); // stop in front of sprite (at front of segment)\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  for (n = 0; n < playerSegment.cars.length; n++) {\n\t    car = playerSegment.cars[n];\n\t    carW = car.sprite.w * _constants.SPRITES.SCALE;\n\t    if (speed > car.speed) {\n\t      if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {\n\t        speed = car.speed * (car.speed / speed);\n\t        position = Util.increase(car.z, -playerZ, trackLength);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  playerX = Util.limit(playerX, -3, 3); // dont ever let it go too far out of bounds\n\t  speed = Util.limit(speed, 0, maxSpeed); // or exceed maxSpeed\n\t\n\t  skyOffset = Util.increase(skyOffset, skySpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);\n\t  hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);\n\t  treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);\n\t\n\t  if (position > playerZ) {\n\t    if (currentLapTime && startPosition < playerZ) {\n\t      // lastLapTime    = currentLapTime;\n\t      // currentLapTime = 0;\n\t      // if (lastLapTime <= Util.toFloat(Dom.storage.fast_lap_time)) {\n\t      //   Dom.storage.fast_lap_time = lastLapTime;\n\t      //   updateHud('fast_lap_time', formatTime(lastLapTime));\n\t      //   Dom.addClassName('fast_lap_time', 'fastest');\n\t      //   Dom.addClassName('last_lap_time', 'fastest');\n\t      // }\n\t      // else {\n\t      //   Dom.removeClassName('fast_lap_time', 'fastest');\n\t      //   Dom.removeClassName('last_lap_time', 'fastest');\n\t      // }\n\t      // updateHud('last_lap_time', formatTime(lastLapTime));\n\t      // Dom.show('last_lap_time');\n\t    } else {\n\t      currentLapTime += dt;\n\t    }\n\t  }\n\t\n\t  updateHud('speed', 5 * Math.round(speed / 500));\n\t  updateHud('current_lap_time', formatTime(currentLapTime));\n\t}\n\t\n\tfunction updateCars(dt, playerSegment, playerW) {\n\t  var n, car, oldSegment, newSegment;\n\t  for (n = 0; n < cars.length; n++) {\n\t    car = cars[n];\n\t    oldSegment = findSegment(car.z);\n\t    car.offset = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);\n\t    car.z = Util.increase(car.z, dt * car.speed, trackLength);\n\t    car.percent = Util.percentRemaining(car.z, segmentLength); // useful for interpolation during rendering phase\n\t    newSegment = findSegment(car.z);\n\t    if (oldSegment != newSegment) {\n\t      index = oldSegment.cars.indexOf(car);\n\t      oldSegment.cars.splice(index, 1);\n\t      newSegment.cars.push(car);\n\t    }\n\t  }\n\t}\n\t\n\tfunction updateCarOffset(car, carSegment, playerSegment, playerW) {\n\t  var i,\n\t      j,\n\t      dir,\n\t      segment,\n\t      otherCar,\n\t      otherCarW,\n\t      lookahead = 20,\n\t      carW = car.sprite.w * _constants.SPRITES.SCALE;\n\t\n\t  // optimization, dont bother steering around other cars when 'out of sight' of the player\n\t  if (carSegment.index - playerSegment.index > drawDistance) {\n\t    return 0;\n\t  }\n\t\n\t  for (i = 1; i < lookahead; i++) {\n\t    segment = segments[(carSegment.index + i) % segments.length];\n\t\n\t    if (segment === playerSegment && car.speed > speed && Util.overlap(playerX, playerW, car.offset, carW, 1.2)) {\n\t      if (playerX > 0.5) {\n\t        dir = -1;\n\t      } else if (playerX < -0.5) {\n\t        dir = 1;\n\t      } else {\n\t        dir = car.offset > playerX ? 1 : -1;\n\t      }\n\t\n\t      return dir * 1 / i * (car.speed - speed) / maxSpeed; // the closer the cars (smaller i) and the greated the speed ratio, the larger the offset\n\t    }\n\t\n\t    for (j = 0; j < segment.cars.length; j++) {\n\t      otherCar = segment.cars[j];\n\t      otherCarW = otherCar.sprite.w * _constants.SPRITES.SCALE;\n\t      if (car.speed > otherCar.speed && Util.overlap(car.offset, carW, otherCar.offset, otherCarW, 1.2)) {\n\t        if (otherCar.offset > 0.5) {\n\t          dir = -1;\n\t        } else if (otherCar.offset < -0.5) {\n\t          dir = 1;\n\t        } else {\n\t          dir = car.offset > otherCar.offset ? 1 : -1;\n\t        }\n\t\n\t        return dir * 1 / i * (car.speed - otherCar.speed) / maxSpeed;\n\t      }\n\t    }\n\t  }\n\t\n\t  // if no cars ahead, but I have somehow ended up off road, then steer back on\n\t  if (car.offset < -0.9) {\n\t    return 0.1;\n\t  } else if (car.offset > 0.9) {\n\t    return -0.1;\n\t  } else {\n\t    return 0;\n\t  }\n\t}\n\t\n\t//-------------------------------------------------------------------------\n\t\n\tfunction updateHud(key, value) {\n\t  // accessing DOM can be slow, so only do it if value has changed\n\t  if (hud[key].value !== value) {\n\t    hud[key].value = value;\n\t    _dom2.default.set(hud[key].dom, value);\n\t  }\n\t}\n\t\n\tfunction formatTime(dt) {\n\t  var minutes = Math.floor(dt / 60);\n\t  var seconds = Math.floor(dt - minutes * 60);\n\t  var tenths = Math.floor(10 * (dt - Math.floor(dt)));\n\t  if (minutes > 0) {\n\t    return minutes + \".\" + (seconds < 10 ? \"0\" : \"\") + seconds + \".\" + tenths;\n\t  } else {\n\t    return seconds + \".\" + tenths;\n\t  }\n\t}\n\t\n\t//=========================================================================\n\t// RENDER THE GAME WORLD\n\t//=========================================================================\n\t\n\tfunction render() {\n\t  var baseSegment = findSegment(position);\n\t  var basePercent = Util.percentRemaining(position, segmentLength);\n\t  var playerSegment = findSegment(position + playerZ);\n\t  var playerPercent = Util.percentRemaining(position + playerZ, segmentLength);\n\t  var playerY = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);\n\t  var maxy = height;\n\t  var x = 0;\n\t  var dx = -(baseSegment.curve * basePercent);\n\t\n\t  ctx.clearRect(0, 0, width, height);\n\t\n\t  _render2.default.background(ctx, background, width, height, _constants.BACKGROUND.SKY, skyOffset, resolution * skySpeed * playerY);\n\t  _render2.default.background(ctx, background, width, height, _constants.BACKGROUND.HILLS, hillOffset, resolution * hillSpeed * playerY);\n\t  _render2.default.background(ctx, background, width, height, _constants.BACKGROUND.TREES, treeOffset, resolution * treeSpeed * playerY);\n\t\n\t  var n = void 0,\n\t      i = void 0,\n\t      segment = void 0,\n\t      car = void 0,\n\t      sprite = void 0,\n\t      spriteScale = void 0,\n\t      spriteX = void 0,\n\t      spriteY = void 0;\n\t\n\t  for (n = 0; n < drawDistance; n++) {\n\t    segment = segments[(baseSegment.index + n) % segments.length];\n\t    segment.looped = segment.index < baseSegment.index;\n\t    segment.fog = Util.exponentialFog(n / drawDistance, fogDensity);\n\t    segment.clip = maxy;\n\t\n\t    Util.project(segment.p1, playerX * roadWidth - x, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);\n\t    Util.project(segment.p2, playerX * roadWidth - x - dx, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);\n\t\n\t    x = x + dx;\n\t    dx = dx + segment.curve;\n\t\n\t    if (segment.p1.camera.z <= cameraDepth || // behind us\n\t    segment.p2.screen.y >= segment.p1.screen.y || // back face cull\n\t    segment.p2.screen.y >= maxy) // clip by (already rendered) hill\n\t      continue;\n\t\n\t    _render2.default.segment(ctx, width, lanes, segment.p1.screen.x, segment.p1.screen.y, segment.p1.screen.w, segment.p2.screen.x, segment.p2.screen.y, segment.p2.screen.w, segment.fog, segment.color);\n\t\n\t    maxy = segment.p1.screen.y;\n\t  }\n\t\n\t  for (n = drawDistance - 1; n > 0; n--) {\n\t    segment = segments[(baseSegment.index + n) % segments.length];\n\t\n\t    for (i = 0; i < segment.cars.length; i++) {\n\t      car = segment.cars[i];\n\t      sprite = car.sprite;\n\t      spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);\n\t      spriteX = Util.interpolate(segment.p1.screen.x, segment.p2.screen.x, car.percent) + spriteScale * car.offset * roadWidth * width / 2;\n\t      spriteY = Util.interpolate(segment.p1.screen.y, segment.p2.screen.y, car.percent);\n\t      _render2.default.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);\n\t    }\n\t\n\t    for (i = 0; i < segment.sprites.length; i++) {\n\t      sprite = segment.sprites[i];\n\t      spriteScale = segment.p1.screen.scale;\n\t      spriteX = segment.p1.screen.x + spriteScale * sprite.offset * roadWidth * width / 2;\n\t      spriteY = segment.p1.screen.y;\n\t      _render2.default.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, sprite.offset < 0 ? -1 : 0, -1, segment.clip);\n\t    }\n\t\n\t    if (segment == playerSegment) {\n\t      _render2.default.player(ctx, width, height, resolution, roadWidth, sprites, speed / maxSpeed, cameraDepth / playerZ, width / 2, height / 2 - cameraDepth / playerZ * Util.interpolate(playerSegment.p1.camera.y, playerSegment.p2.camera.y, playerPercent) * height / 2, speed * (keyLeft ? -1 : keyRight ? 1 : 0), playerSegment.p2.world.y - playerSegment.p1.world.y);\n\t    }\n\t  }\n\t}\n\t\n\tfunction findSegment(z) {\n\t  return segments[Math.floor(z / segmentLength) % segments.length];\n\t}\n\t\n\t//=========================================================================\n\t// BUILD ROAD GEOMETRY\n\t//=========================================================================\n\t\n\tfunction lastY() {\n\t  return segments.length == 0 ? 0 : segments[segments.length - 1].p2.world.y;\n\t}\n\t\n\tfunction addSegment(curve, y) {\n\t  var n = segments.length;\n\t  segments.push({\n\t    index: n,\n\t    p1: { world: { y: lastY(), z: n * segmentLength }, camera: {}, screen: {} },\n\t    p2: { world: { y: y, z: (n + 1) * segmentLength }, camera: {}, screen: {} },\n\t    curve: curve,\n\t    sprites: [],\n\t    cars: [],\n\t    color: Math.floor(n / rumbleLength) % 2 ? _constants.COLORS.DARK : _constants.COLORS.LIGHT\n\t  });\n\t}\n\t\n\tfunction addSprite(n, sprite, offset) {\n\t  segments[n].sprites.push({ source: sprite, offset: offset });\n\t}\n\t\n\tfunction addRoad(enter, hold, leave, curve, y) {\n\t  var startY = lastY();\n\t  var endY = startY + Util.toInt(y, 0) * segmentLength;\n\t  var n,\n\t      total = enter + hold + leave;\n\t  for (n = 0; n < enter; n++) {\n\t    addSegment(Util.easeIn(0, curve, n / enter), Util.easeInOut(startY, endY, n / total));\n\t  }for (n = 0; n < hold; n++) {\n\t    addSegment(curve, Util.easeInOut(startY, endY, (enter + n) / total));\n\t  }for (n = 0; n < leave; n++) {\n\t    addSegment(Util.easeInOut(curve, 0, n / leave), Util.easeInOut(startY, endY, (enter + hold + n) / total));\n\t  }\n\t}\n\t\n\tvar ROAD = {\n\t  LENGTH: { NONE: 0, SHORT: 25, MEDIUM: 50, LONG: 100 },\n\t  HILL: { NONE: 0, LOW: 20, MEDIUM: 40, HIGH: 60 },\n\t  CURVE: { NONE: 0, EASY: 2, MEDIUM: 4, HARD: 6 }\n\t};\n\t\n\tfunction addStraight(num) {\n\t  num = num || ROAD.LENGTH.MEDIUM;\n\t  addRoad(num, num, num, 0, 0);\n\t}\n\t\n\tfunction addHill(num, height) {\n\t  num = num || ROAD.LENGTH.MEDIUM;\n\t  height = height || ROAD.HILL.MEDIUM;\n\t  addRoad(num, num, num, 0, height);\n\t}\n\t\n\tfunction addCurve(num, curve, height) {\n\t  num = num || ROAD.LENGTH.MEDIUM;\n\t  curve = curve || ROAD.CURVE.MEDIUM;\n\t  height = height || ROAD.HILL.NONE;\n\t  addRoad(num, num, num, curve, height);\n\t}\n\t\n\tfunction addLowRollingHills(num, height) {\n\t  num = num || ROAD.LENGTH.SHORT;\n\t  height = height || ROAD.HILL.LOW;\n\t  addRoad(num, num, num, 0, height / 2);\n\t  addRoad(num, num, num, 0, -height);\n\t  addRoad(num, num, num, ROAD.CURVE.EASY, height);\n\t  addRoad(num, num, num, 0, 0);\n\t  addRoad(num, num, num, -ROAD.CURVE.EASY, height / 2);\n\t  addRoad(num, num, num, 0, 0);\n\t}\n\t\n\tfunction addSCurves() {\n\t  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY, ROAD.HILL.NONE);\n\t  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);\n\t  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.EASY, -ROAD.HILL.LOW);\n\t  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY, ROAD.HILL.MEDIUM);\n\t  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.MEDIUM, -ROAD.HILL.MEDIUM);\n\t}\n\t\n\tfunction addBumps() {\n\t  addRoad(10, 10, 10, 0, 5);\n\t  addRoad(10, 10, 10, 0, -2);\n\t  addRoad(10, 10, 10, 0, -5);\n\t  addRoad(10, 10, 10, 0, 8);\n\t  addRoad(10, 10, 10, 0, 5);\n\t  addRoad(10, 10, 10, 0, -7);\n\t  addRoad(10, 10, 10, 0, 5);\n\t  addRoad(10, 10, 10, 0, -2);\n\t}\n\t\n\tfunction addDownhillToEnd(num) {\n\t  num = num || 200;\n\t  addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY() / segmentLength);\n\t}\n\t\n\tfunction resetRoad() {\n\t  segments = [];\n\t\n\t  addStraight(ROAD.LENGTH.SHORT);\n\t  addLowRollingHills();\n\t  addSCurves();\n\t  addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);\n\t  addBumps();\n\t  addLowRollingHills();\n\t  addCurve(ROAD.LENGTH.LONG * 2, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);\n\t  addStraight();\n\t  addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);\n\t  addSCurves();\n\t  addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.MEDIUM, ROAD.HILL.NONE);\n\t  addHill(ROAD.LENGTH.LONG, ROAD.HILL.HIGH);\n\t  addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);\n\t  addBumps();\n\t  addHill(ROAD.LENGTH.LONG, -ROAD.HILL.MEDIUM);\n\t  addStraight();\n\t  addSCurves();\n\t  addDownhillToEnd();\n\t\n\t  resetSprites();\n\t  resetCars();\n\t\n\t  segments[findSegment(playerZ).index + 2].color = _constants.COLORS.START;\n\t  segments[findSegment(playerZ).index + 3].color = _constants.COLORS.START;\n\t  for (var n = 0; n < rumbleLength; n++) {\n\t    segments[segments.length - 1 - n].color = _constants.COLORS.FINISH;\n\t  }trackLength = segments.length * segmentLength;\n\t}\n\t\n\tfunction resetSprites() {\n\t  var n, i;\n\t\n\t  // addSprite(20,  SPRITES.BILLBOARD07, -1);\n\t  // addSprite(40,  SPRITES.BILLBOARD06, -1);\n\t  // addSprite(60,  SPRITES.BILLBOARD08, -1);\n\t  // addSprite(80,  SPRITES.BILLBOARD09, -1);\n\t  // addSprite(100, SPRITES.BILLBOARD01, -1);\n\t  // addSprite(120, SPRITES.BILLBOARD02, -1);\n\t  // addSprite(140, SPRITES.BILLBOARD03, -1);\n\t  // addSprite(160, SPRITES.BILLBOARD04, -1);\n\t  // addSprite(180, SPRITES.BILLBOARD05, -1);\n\t\n\t  // addSprite(240,                  SPRITES.BILLBOARD07, -1.2);\n\t  // addSprite(240,                  SPRITES.BILLBOARD06,  1.2);\n\t  // addSprite(segments.length - 25, SPRITES.BILLBOARD07, -1.2);\n\t  // addSprite(segments.length - 25, SPRITES.BILLBOARD06,  1.2);\n\t\n\t  // for(n = 10 ; n < 200 ; n += 4 + Math.floor(n/100)) {\n\t  //   addSprite(n, SPRITES.PALM_TREE, 0.5 + Math.random()*0.5);\n\t  //   addSprite(n, SPRITES.PALM_TREE,   1 + Math.random()*2);\n\t  // }\n\t\n\t  // for(n = 250 ; n < 1000 ; n += 5) {\n\t  //   addSprite(n,     SPRITES.COLUMN, 1.1);\n\t  //   addSprite(n + Util.randomInt(0,5), SPRITES.TREE1, -1 - (Math.random() * 2));\n\t  //   addSprite(n + Util.randomInt(0,5), SPRITES.TREE2, -1 - (Math.random() * 2));\n\t  // }\n\t\n\t  // for(n = 200 ; n < segments.length ; n += 3) {\n\t  //   addSprite(n, Util.randomChoice(SPRITES.PLANTS), Util.randomChoice([1,-1]) * (2 + Math.random() * 5));\n\t  // }\n\t\n\t  // var side, sprite, offset;\n\t  // for(n = 1000 ; n < (segments.length-50) ; n += 100) {\n\t  //   side      = Util.randomChoice([1, -1]);\n\t  //   addSprite(n + Util.randomInt(0, 50), Util.randomChoice(SPRITES.BILLBOARDS), -side);\n\t  //   for(i = 0 ; i < 20 ; i++) {\n\t  //     sprite = Util.randomChoice(SPRITES.PLANTS);\n\t  //     offset = side * (1.5 + Math.random());\n\t  //     addSprite(n + Util.randomInt(0, 50), sprite, offset);\n\t  //   }\n\t\n\t  // }\n\t}\n\t\n\tfunction resetCars() {\n\t  cars = [];\n\t  var n, car, segment, offset, z, sprite, speed;\n\t  for (var n = 0; n < totalCars; n++) {\n\t    offset = Math.random() * Util.randomChoice([-0.8, 0.8]);\n\t    z = Math.floor(Math.random() * segments.length) * segmentLength;\n\t    sprite = Util.randomChoice(_constants.SPRITES.CARS);\n\t    speed = maxSpeed / 4 + Math.random() * maxSpeed / (sprite == _constants.SPRITES.SEMI ? 4 : 2);\n\t    car = { offset: offset, z: z, sprite: sprite, speed: speed };\n\t    segment = findSegment(car.z);\n\t    segment.cars.push(car);\n\t    cars.push(car);\n\t  }\n\t}\n\t\n\t//=========================================================================\n\t// THE GAME LOOP\n\t//=========================================================================\n\t\n\tvar newGame = new _game2.default();\n\t\n\tnewGame.run({\n\t  canvas: canvas,\n\t  render: render,\n\t  update: update,\n\t  step: step,\n\t  images: [\"intro\", \"background\", \"sprites\"],\n\t  keys: [{ keys: [_constants.KEY.LEFT, _constants.KEY.A], mode: 'down', action: function action() {\n\t      keyLeft = true;\n\t    } }, { keys: [_constants.KEY.RIGHT, _constants.KEY.D], mode: 'down', action: function action() {\n\t      keyRight = true;\n\t    } }, { keys: [_constants.KEY.UP, _constants.KEY.W], mode: 'down', action: function action() {\n\t      keyFaster = true;\n\t    } }, { keys: [_constants.KEY.DOWN, _constants.KEY.S], mode: 'down', action: function action() {\n\t      keySlower = true;\n\t    } }, { keys: [_constants.KEY.LEFT, _constants.KEY.A], mode: 'up', action: function action() {\n\t      keyLeft = false;\n\t    } }, { keys: [_constants.KEY.RIGHT, _constants.KEY.D], mode: 'up', action: function action() {\n\t      keyRight = false;\n\t    } }, { keys: [_constants.KEY.UP, _constants.KEY.W], mode: 'up', action: function action() {\n\t      keyFaster = false;\n\t    } }, { keys: [_constants.KEY.DOWN, _constants.KEY.S], mode: 'up', action: function action() {\n\t      keySlower = false;\n\t    } }],\n\t  ready: function ready(images) {\n\t    if (gameState === 'intro' || gameState === 'select_player') {\n\t      background = images[0];\n\t    } else {\n\t      background = images[0];\n\t      sprites = images[1];\n\t    }\n\t    console.log('BACK: ', background);\n\t    reset();\n\t    // Dom.storage.fast_lap_time = Dom.storage.fast_lap_time || 180;\n\t    // updateHud('fast_lap_time', formatTime(Util.toFloat(Dom.storage.fast_lap_time)));\n\t  }\n\t});\n\t\n\tfunction reset(options) {\n\t  options = options || {};\n\t  canvas.width = width = Util.toInt(options.width, width);\n\t  canvas.height = height = Util.toInt(options.height, height);\n\t  lanes = Util.toInt(options.lanes, lanes);\n\t  roadWidth = Util.toInt(options.roadWidth, roadWidth);\n\t  cameraHeight = Util.toInt(options.cameraHeight, cameraHeight);\n\t  drawDistance = Util.toInt(options.drawDistance, drawDistance);\n\t  fogDensity = Util.toInt(options.fogDensity, fogDensity);\n\t  fieldOfView = Util.toInt(options.fieldOfView, fieldOfView);\n\t  segmentLength = Util.toInt(options.segmentLength, segmentLength);\n\t  rumbleLength = Util.toInt(options.rumbleLength, rumbleLength);\n\t  cameraDepth = 1 / Math.tan(fieldOfView / 2 * Math.PI / 180);\n\t  playerZ = cameraHeight * cameraDepth;\n\t  resolution = height / 480;\n\t  refreshTweakUI();\n\t\n\t  if (segments.length == 0 || options.segmentLength || options.rumbleLength) resetRoad(); // only rebuild road when necessary\n\t}\n\t\n\t//=========================================================================\n\t// TWEAK UI HANDLERS\n\t//=========================================================================\n\t\n\t// Dom.on('resolution', 'change', function(ev) {\n\t//   var w, h, ratio;\n\t//   switch(ev.target.options[ev.target.selectedIndex].value) {\n\t//     case 'fine':   w = 1280; h = 960;  ratio=w/width; break;\n\t//     case 'high':   w = 1024; h = 768;  ratio=w/width; break;\n\t//     case 'medium': w = 640;  h = 480;  ratio=w/width; break;\n\t//     case 'low':    w = 480;  h = 360;  ratio=w/width; break;\n\t//   }\n\t//   reset({ width: w, height: h })\n\t//   Dom.blur(ev);\n\t// });\n\t\n\t// Dom.on('lanes',          'change', function(ev) { Dom.blur(ev); reset({ lanes:         ev.target.options[ev.target.selectedIndex].value }); });\n\t// Dom.on('roadWidth',      'change', function(ev) { Dom.blur(ev); reset({ roadWidth:     Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n\t// Dom.on('cameraHeight',   'change', function(ev) { Dom.blur(ev); reset({ cameraHeight:  Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n\t// Dom.on('drawDistance',   'change', function(ev) { Dom.blur(ev); reset({ drawDistance:  Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n\t// Dom.on('fieldOfView',    'change', function(ev) { Dom.blur(ev); reset({ fieldOfView:   Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n\t// Dom.on('fogDensity',     'change', function(ev) { Dom.blur(ev); reset({ fogDensity:    Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n\t\n\tfunction refreshTweakUI() {\n\t  _dom2.default.get('lanes').selectedIndex = lanes - 1;\n\t  _dom2.default.get('currentRoadWidth').innerHTML = _dom2.default.get('roadWidth').value = roadWidth;\n\t  _dom2.default.get('currentCameraHeight').innerHTML = _dom2.default.get('cameraHeight').value = cameraHeight;\n\t  _dom2.default.get('currentDrawDistance').innerHTML = _dom2.default.get('drawDistance').value = drawDistance;\n\t  _dom2.default.get('currentFieldOfView').innerHTML = _dom2.default.get('fieldOfView').value = fieldOfView;\n\t  _dom2.default.get('currentFogDensity').innerHTML = _dom2.default.get('fogDensity').value = fogDensity;\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t//=========================================================================\n\t// general purpose helpers (mostly math)\n\t//=========================================================================\n\t\n\tvar timestamp = function timestamp() {\n\t  return new Date().getTime();\n\t};\n\tvar toInt = function toInt(obj, def) {\n\t  if (obj !== null) {\n\t    var x = parseInt(obj, 10);\n\t    if (!isNaN(x)) return x;\n\t  }return toInt(def, 0);\n\t};\n\tvar toFloat = function toFloat(obj, def) {\n\t  if (obj !== null) {\n\t    var x = parseFloat(obj);\n\t    if (!isNaN(x)) return x;\n\t  }\n\t  return toFloat(def, 0.0);\n\t};\n\tvar limit = function limit(value, min, max) {\n\t  return Math.max(min, Math.min(value, max));\n\t};\n\tvar randomInt = function randomInt(min, max) {\n\t  return Math.round(interpolate(min, max, Math.random()));\n\t};\n\tvar randomChoice = function randomChoice(options) {\n\t  return options[randomInt(0, options.length - 1)];\n\t};\n\tvar percentRemaining = function percentRemaining(n, total) {\n\t  return n % total / total;\n\t};\n\tvar accelerate = function accelerate(v, accel, dt) {\n\t  return v + accel * dt;\n\t};\n\tvar interpolate = function interpolate(a, b, percent) {\n\t  return a + (b - a) * percent;\n\t};\n\tvar easeIn = function easeIn(a, b, percent) {\n\t  return a + (b - a) * Math.pow(percent, 2);\n\t};\n\tvar easeOut = function easeOut(a, b, percent) {\n\t  return a + (b - a) * (1 - Math.pow(1 - percent, 2));\n\t};\n\tvar easeInOut = function easeInOut(a, b, percent) {\n\t  return a + (b - a) * (-Math.cos(percent * Math.PI) / 2 + 0.5);\n\t};\n\tvar exponentialFog = function exponentialFog(distance, density) {\n\t  return 1 / Math.pow(Math.E, distance * distance * density);\n\t};\n\t\n\tvar increase = function increase(start, increment, max) {\n\t  // with looping\n\t  var result = start + increment;\n\t  while (result >= max) {\n\t    result -= max;\n\t  }while (result < 0) {\n\t    result += max;\n\t  }return result;\n\t};\n\t\n\tvar project = function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {\n\t  p.camera.x = (p.world.x || 0) - cameraX;\n\t  p.camera.y = (p.world.y || 0) - cameraY;\n\t  p.camera.z = (p.world.z || 0) - cameraZ;\n\t  p.screen.scale = cameraDepth / p.camera.z;\n\t  p.screen.x = Math.round(width / 2 + p.screen.scale * p.camera.x * width / 2);\n\t  p.screen.y = Math.round(height / 2 - p.screen.scale * p.camera.y * height / 2);\n\t  p.screen.w = Math.round(p.screen.scale * roadWidth * width / 2);\n\t};\n\t\n\tvar overlap = function overlap(x1, w1, x2, w2, percent) {\n\t  var half = (percent || 1) / 2;\n\t  var min1 = x1 - w1 * half;\n\t  var max1 = x1 + w1 * half;\n\t  var min2 = x2 - w2 * half;\n\t  var max2 = x2 + w2 * half;\n\t  return !(max1 < min2 || min1 > max2);\n\t};\n\t\n\texports.timestamp = timestamp;\n\texports.toInt = toInt;\n\texports.toFloat = toFloat;\n\texports.limit = limit;\n\texports.randomInt = randomInt;\n\texports.randomChoice = randomChoice;\n\texports.percentRemaining = percentRemaining;\n\texports.accelerate = accelerate;\n\texports.interpolate = interpolate;\n\texports.easeIn = easeIn;\n\texports.easeOut = easeOut;\n\texports.easeInOut = easeInOut;\n\texports.exponentialFog = exponentialFog;\n\texports.increase = increase;\n\texports.project = project;\n\texports.overlap = overlap;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//=========================================================================\n\t// minimalist DOM helpers\n\t//=========================================================================\n\t\n\tvar Dom = function () {\n\t  function Dom() {\n\t    _classCallCheck(this, Dom);\n\t\n\t    this.storage = window.localStorage || {};\n\t  }\n\t\n\t  _createClass(Dom, [{\n\t    key: 'get',\n\t    value: function get(id) {\n\t      return id instanceof HTMLElement || id === document ? id : document.getElementById(id);\n\t    }\n\t  }, {\n\t    key: 'set',\n\t    value: function set(id, html) {\n\t      this.get(id).innerHTML = html;\n\t    }\n\t  }, {\n\t    key: 'on',\n\t    value: function on(ele, type, fn, capture) {\n\t      this.get(ele).addEventListener(type, fn, capture);\n\t    }\n\t  }, {\n\t    key: 'un',\n\t    value: function un(ele, type, fn, capture) {\n\t      this.get(ele).removeEventListener(type, fn, capture);\n\t    }\n\t  }, {\n\t    key: 'show',\n\t    value: function show(ele, type) {\n\t      this.get(ele).style.display = type || 'block';\n\t    }\n\t  }, {\n\t    key: 'blur',\n\t    value: function blur(ev) {\n\t      ev.target.blur();\n\t    }\n\t  }, {\n\t    key: 'addClassName',\n\t    value: function addClassName(ele, name) {\n\t      this.toggleClassName(ele, name, true);\n\t    }\n\t  }, {\n\t    key: 'removeClassName',\n\t    value: function removeClassName(ele, name) {\n\t      this.toggleClassName(ele, name, false);\n\t    }\n\t  }, {\n\t    key: 'toggleClassName',\n\t    value: function toggleClassName(ele, name, on) {\n\t      ele = this.get(ele);\n\t      var classes = ele.className.split(' ');\n\t      var n = classes.indexOf(name);\n\t      on = typeof on == 'undefined' ? n < 0 : on;\n\t      if (on && n < 0) classes.push(name);else if (!on && n >= 0) classes.splice(n, 1);\n\t      ele.className = classes.join(' ');\n\t    }\n\t  }]);\n\t\n\t  return Dom;\n\t}();\n\t\n\tvar dom = new Dom();\n\t\n\texports.default = dom;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t//=============================================================================\n\t// RACING GAME CONSTANTS\n\t//=============================================================================\n\t\n\tvar KEY = {\n\t  LEFT: 37,\n\t  UP: 38,\n\t  RIGHT: 39,\n\t  DOWN: 40,\n\t  A: 65,\n\t  D: 68,\n\t  S: 83,\n\t  W: 87\n\t};\n\t\n\tvar COLORS = {\n\t  SKY: '#72D7EE',\n\t  TREE: '#005108',\n\t  FOG: '#005108',\n\t  LIGHT: { road: '#6B6B6B', grass: '#10AA10', rumble: '#555555', lane: '#CCCCCC' },\n\t  DARK: { road: '#696969', grass: '#009A00', rumble: '#BBBBBB' },\n\t  START: { road: 'white', grass: 'white', rumble: 'white' },\n\t  FINISH: { road: 'black', grass: 'black', rumble: 'black' }\n\t};\n\t\n\tvar BACKGROUND = {\n\t  HILLS: { x: 5, y: 5, w: 1280, h: 480 },\n\t  SKY: { x: 5, y: 495, w: 1280, h: 480 },\n\t  TREES: { x: 5, y: 985, w: 1280, h: 480 }\n\t};\n\t\n\tvar SPRITES = {\n\t  PALM_TREE: { x: 5, y: 5, w: 215, h: 540 },\n\t  BILLBOARD08: { x: 230, y: 5, w: 385, h: 265 },\n\t  TREE1: { x: 625, y: 5, w: 360, h: 360 },\n\t  DEAD_TREE1: { x: 5, y: 555, w: 135, h: 332 },\n\t  BILLBOARD09: { x: 150, y: 555, w: 328, h: 282 },\n\t  BOULDER3: { x: 230, y: 280, w: 320, h: 220 },\n\t  COLUMN: { x: 995, y: 5, w: 200, h: 315 },\n\t  BILLBOARD01: { x: 625, y: 375, w: 300, h: 170 },\n\t  BILLBOARD06: { x: 488, y: 555, w: 298, h: 190 },\n\t  BILLBOARD05: { x: 5, y: 897, w: 298, h: 190 },\n\t  BILLBOARD07: { x: 313, y: 897, w: 298, h: 190 },\n\t  BOULDER2: { x: 621, y: 897, w: 298, h: 140 },\n\t  TREE2: { x: 1205, y: 5, w: 282, h: 295 },\n\t  BILLBOARD04: { x: 1205, y: 310, w: 268, h: 170 },\n\t  DEAD_TREE2: { x: 1205, y: 490, w: 150, h: 260 },\n\t  BOULDER1: { x: 1205, y: 760, w: 168, h: 248 },\n\t  BUSH1: { x: 5, y: 1097, w: 240, h: 155 },\n\t  CACTUS: { x: 929, y: 897, w: 235, h: 118 },\n\t  BUSH2: { x: 255, y: 1097, w: 232, h: 152 },\n\t  BILLBOARD03: { x: 5, y: 1262, w: 230, h: 220 },\n\t  BILLBOARD02: { x: 245, y: 1262, w: 215, h: 220 },\n\t  STUMP: { x: 995, y: 330, w: 195, h: 140 },\n\t  SEMI: { x: 1365, y: 490, w: 122, h: 144 },\n\t  TRUCK: { x: 1365, y: 644, w: 100, h: 78 },\n\t  CAR03: { x: 1383, y: 760, w: 88, h: 55 },\n\t  CAR02: { x: 1383, y: 825, w: 80, h: 59 },\n\t  CAR04: { x: 1383, y: 894, w: 80, h: 57 },\n\t  CAR01: { x: 1205, y: 1018, w: 80, h: 56 },\n\t  PLAYER_UPHILL_LEFT: { x: 1383, y: 961, w: 80, h: 45 },\n\t  PLAYER_UPHILL_STRAIGHT: { x: 1295, y: 1018, w: 80, h: 45 },\n\t  PLAYER_UPHILL_RIGHT: { x: 1385, y: 1018, w: 80, h: 45 },\n\t  PLAYER_LEFT: { x: 992, y: 480, w: 90, h: 67 },\n\t  PLAYER_STRAIGHT: { x: 1086, y: 470, w: 86, h: 77 },\n\t  PLAYER_RIGHT: { x: 992, y: 548, w: 90, h: 67 }\n\t};\n\t\n\tSPRITES.SCALE = 0.3 * (1 / SPRITES.PLAYER_STRAIGHT.w); // the reference sprite width should be 1/3rd the (half-)roadWidth\n\tSPRITES.BILLBOARDS = [SPRITES.BILLBOARD01, SPRITES.BILLBOARD02, SPRITES.BILLBOARD03, SPRITES.BILLBOARD04, SPRITES.BILLBOARD05, SPRITES.BILLBOARD06, SPRITES.BILLBOARD07, SPRITES.BILLBOARD08, SPRITES.BILLBOARD09];\n\tSPRITES.PLANTS = [SPRITES.TREE1, SPRITES.TREE2, SPRITES.DEAD_TREE1, SPRITES.DEAD_TREE2, SPRITES.PALM_TREE, SPRITES.BUSH1, SPRITES.BUSH2, SPRITES.CACTUS, SPRITES.STUMP, SPRITES.BOULDER1, SPRITES.BOULDER2, SPRITES.BOULDER3];\n\tSPRITES.CARS = [SPRITES.CAR01, SPRITES.CAR02, SPRITES.CAR03, SPRITES.CAR04, SPRITES.SEMI, SPRITES.TRUCK];\n\t\n\texports.KEY = KEY;\n\texports.COLORS = COLORS;\n\texports.BACKGROUND = BACKGROUND;\n\texports.SPRITES = SPRITES;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _dom = __webpack_require__(2);\n\t\n\tvar _dom2 = _interopRequireDefault(_dom);\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//=========================================================================\n\t// GAME LOOP helpers\n\t//=========================================================================\n\t\n\tvar Game = function () {\n\t  function Game() {\n\t    _classCallCheck(this, Game);\n\t  }\n\t\n\t  _createClass(Game, [{\n\t    key: 'run',\n\t    value: function run(options) {\n\t      var _this = this;\n\t\n\t      this.loadImages(options.images, function (images) {\n\t\n\t        options.ready(images); // tell caller to initialize itself because images are loaded and we're ready to rumble\n\t\n\t        _this.setKeyListener(options.keys);\n\t\n\t        var canvas = options.canvas,\n\t            // canvas render target is provided by caller\n\t        update = options.update,\n\t            // method to update game logic is provided by caller\n\t        render = options.render,\n\t            // method to render the game is provided by caller\n\t        step = options.step,\n\t            // fixed frame step (1/fps) is specified by caller\n\t        now = null,\n\t            last = (0, _util.timestamp)(),\n\t            dt = 0,\n\t            gdt = 0;\n\t\n\t        function frame() {\n\t          now = (0, _util.timestamp)();\n\t          dt = Math.min(1, (now - last) / 1000); // using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab\n\t          gdt = gdt + dt;\n\t          while (gdt > step) {\n\t            gdt = gdt - step;\n\t            update(step);\n\t          }\n\t          render();\n\t          last = now;\n\t          requestAnimationFrame(frame, canvas);\n\t        }\n\t        frame(); // lets get this party started\n\t\n\t        // Game.playMusic();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'loadImages',\n\t    value: function loadImages(names, callback) {\n\t      // load multiple images and callback when ALL images have loaded\n\t      var preloadImage = function preloadImage(path) {\n\t        return new Promise(function (resolve, reject) {\n\t          var image = new Image();\n\t          image.onload = resolve(image);\n\t          image.onerror = resolve();\n\t          image.src = path;\n\t        });\n\t      };\n\t\n\t      Promise.all(names.map(function (url) {\n\t        var imgUrl = '../static/images/' + url + '.png';\n\t        return preloadImage(imgUrl);\n\t      })).then(function (arr) {\n\t        callback(arr);\n\t      }).catch(function (err) {\n\t        callback(err);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'setKeyListener',\n\t    value: function setKeyListener(keys) {\n\t      var onkey = function onkey(keyCode, mode) {\n\t        var n, k;\n\t        for (n = 0; n < keys.length; n++) {\n\t          k = keys[n];\n\t          k.mode = k.mode || 'up';\n\t          if (k.key == keyCode || k.keys && k.keys.indexOf(keyCode) >= 0) {\n\t            if (k.mode == mode) {\n\t              k.action.call();\n\t            }\n\t          }\n\t        }\n\t      };\n\t      _dom2.default.on(document, 'keydown', function (ev) {\n\t        onkey(ev.keyCode, 'down');\n\t      });\n\t      _dom2.default.on(document, 'keyup', function (ev) {\n\t        onkey(ev.keyCode, 'up');\n\t      });\n\t    }\n\t\n\t    // playMusic: function() {\n\t    //   var music = Dom.get('music');\n\t    //   music.loop = true;\n\t    //   music.volume = 0.05; // shhhh! annoying music!\n\t    //   music.muted = (Dom.storage.muted === \"true\");\n\t    //   music.play();\n\t    //   Dom.toggleClassName('mute', 'on', music.muted);\n\t    //   Dom.on('mute', 'click', function() {\n\t    //     Dom.storage.muted = music.muted = !music.muted;\n\t    //     Dom.toggleClassName('mute', 'on', music.muted);\n\t    //   });\n\t    // }\n\t\n\t  }]);\n\t\n\t  return Game;\n\t}();\n\t\n\texports.default = Game;\n\t;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar _constants = __webpack_require__(3);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//=========================================================================\n\t// canvas rendering helpers\n\t//=========================================================================\n\t\n\tvar Render = function () {\n\t  function Render() {\n\t    _classCallCheck(this, Render);\n\t  }\n\t\n\t  _createClass(Render, [{\n\t    key: 'polygon',\n\t    value: function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {\n\t      ctx.fillStyle = color;\n\t      ctx.beginPath();\n\t      ctx.moveTo(x1, y1);\n\t      ctx.lineTo(x2, y2);\n\t      ctx.lineTo(x3, y3);\n\t      ctx.lineTo(x4, y4);\n\t      ctx.closePath();\n\t      ctx.fill();\n\t    }\n\t  }, {\n\t    key: 'segment',\n\t    value: function segment(ctx, width, lanes, x1, y1, w1, x2, y2, w2, fog, color) {\n\t      var r1 = this.rumbleWidth(w1, lanes),\n\t          r2 = this.rumbleWidth(w2, lanes),\n\t          l1 = this.laneMarkerWidth(w1, lanes),\n\t          l2 = this.laneMarkerWidth(w2, lanes),\n\t          lanew1,\n\t          lanew2,\n\t          lanex1,\n\t          lanex2,\n\t          lane;\n\t\n\t      ctx.fillStyle = color.grass;\n\t      ctx.fillRect(0, y2, width, y1 - y2);\n\t\n\t      this.polygon(ctx, x1 - w1 - r1, y1, x1 - w1, y1, x2 - w2, y2, x2 - w2 - r2, y2, color.rumble);\n\t      this.polygon(ctx, x1 + w1 + r1, y1, x1 + w1, y1, x2 + w2, y2, x2 + w2 + r2, y2, color.rumble);\n\t      this.polygon(ctx, x1 - w1, y1, x1 + w1, y1, x2 + w2, y2, x2 - w2, y2, color.road);\n\t\n\t      if (color.lane) {\n\t        lanew1 = w1 * 2 / lanes;\n\t        lanew2 = w2 * 2 / lanes;\n\t        lanex1 = x1 - w1 + lanew1;\n\t        lanex2 = x2 - w2 + lanew2;\n\t        for (lane = 1; lane < lanes; lanex1 += lanew1, lanex2 += lanew2, lane++) {\n\t          this.polygon(ctx, lanex1 - l1 / 2, y1, lanex1 + l1 / 2, y1, lanex2 + l2 / 2, y2, lanex2 - l2 / 2, y2, color.lane);\n\t        }\n\t      }\n\t\n\t      this.fog(ctx, 0, y1, width, y2 - y1, fog);\n\t    }\n\t  }, {\n\t    key: 'background',\n\t    value: function background(ctx, _background, width, height, layer, rotation, offset) {\n\t      rotation = rotation || 0;\n\t      offset = offset || 0;\n\t\n\t      var imageW = layer.w / 2;\n\t      var imageH = layer.h;\n\t\n\t      var sourceX = layer.x + Math.floor(layer.w * rotation);\n\t      var sourceY = layer.y;\n\t      var sourceW = Math.min(imageW, layer.x + layer.w - sourceX);\n\t      var sourceH = imageH;\n\t\n\t      var destX = 0;\n\t      var destY = offset;\n\t      var destW = Math.floor(width * (sourceW / imageW));\n\t      var destH = height;\n\t\n\t      console.log('CTX: ', ctx, _background);\n\t\n\t      ctx.drawImage(_background, sourceX, sourceY, sourceW, sourceH, destX, destY, destW, destH);\n\t      if (sourceW < imageW) ctx.drawImage(_background, layer.x, sourceY, imageW - sourceW, sourceH, destW - 1, destY, width - destW, destH);\n\t    }\n\t  }, {\n\t    key: 'sprite',\n\t    value: function sprite(ctx, width, height, resolution, roadWidth, sprites, _sprite, scale, destX, destY, offsetX, offsetY, clipY) {\n\t      //  scale for projection AND relative to roadWidth (for tweakUI)\n\t      var destW = _sprite.w * scale * width / 2 * (_constants.SPRITES.SCALE * roadWidth);\n\t      var destH = _sprite.h * scale * width / 2 * (_constants.SPRITES.SCALE * roadWidth);\n\t\n\t      destX = destX + destW * (offsetX || 0);\n\t      destY = destY + destH * (offsetY || 0);\n\t\n\t      // console.log('CTX: ', ctx)\n\t\n\t      var clipH = clipY ? Math.max(0, destY + destH - clipY) : 0;\n\t      if (clipH < destH) ctx.drawImage(sprites, _sprite.x, _sprite.y, _sprite.w, _sprite.h - _sprite.h * clipH / destH, destX, destY, destW, destH - clipH);\n\t    }\n\t  }, {\n\t    key: 'player',\n\t    value: function player(ctx, width, height, resolution, roadWidth, sprites, speedPercent, scale, destX, destY, steer, updown) {\n\t      var bounce = 1.5 * Math.random() * speedPercent * resolution * (0, _util.randomChoice)([-1, 1]);\n\t      var sprite;\n\t      if (steer < 0) sprite = updown > 0 ? _constants.SPRITES.PLAYER_UPHILL_LEFT : _constants.SPRITES.PLAYER_LEFT;else if (steer > 0) sprite = updown > 0 ? _constants.SPRITES.PLAYER_UPHILL_RIGHT : _constants.SPRITES.PLAYER_RIGHT;else sprite = updown > 0 ? _constants.SPRITES.PLAYER_UPHILL_STRAIGHT : _constants.SPRITES.PLAYER_STRAIGHT;\n\t\n\t      this.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite, scale, destX, destY + bounce, -0.5, -1);\n\t    }\n\t  }, {\n\t    key: 'fog',\n\t    value: function fog(ctx, x, y, width, height, _fog) {\n\t      if (_fog < 1) {\n\t        ctx.globalAlpha = 1 - _fog;\n\t        ctx.fillStyle = _constants.COLORS.FOG;\n\t        ctx.fillRect(x, y, width, height);\n\t        ctx.globalAlpha = 1;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'rumbleWidth',\n\t    value: function rumbleWidth(projectedRoadWidth, lanes) {\n\t      return projectedRoadWidth / Math.max(6, 2 * lanes);\n\t    }\n\t  }, {\n\t    key: 'laneMarkerWidth',\n\t    value: function laneMarkerWidth(projectedRoadWidth, lanes) {\n\t      return projectedRoadWidth / Math.max(32, 8 * lanes);\n\t    }\n\t  }]);\n\t\n\t  return Render;\n\t}();\n\t\n\tvar render = new Render();\n\texports.default = render;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 93a3ea5148ab2772364d","import Render from 'render';\nimport Game from 'game';\nimport * as Util from 'util';\nimport Dom from 'dom';\nimport { KEY, COLORS, BACKGROUND, SPRITES } from 'constants';\n\n//=========================================================================\n// POLYFILL for requestAnimationFrame\n//=========================================================================\n\nif (!window.requestAnimationFrame) { // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n  window.requestAnimationFrame = window.webkitRequestAnimationFrame || \n                                 window.mozRequestAnimationFrame    || \n                                 window.oRequestAnimationFrame      || \n                                 window.msRequestAnimationFrame     || \n                                 function(callback, element) {\n                                   window.setTimeout(callback, 1000 / 60);\n                                 }\n}\n\n\n//=========================================================================\n\nlet fps            = 60;                      // how many 'update' frames per second\nlet step           = 1/fps;                   // how long is each frame (in seconds)\nlet width          = 1024;                    // logical canvas width\nlet height         = 768;                     // logical canvas height\nlet centrifugal    = 0.3;                     // centrifugal force multiplier when going around curves\n// let offRoadDecel   = 0.99;                    // speed multiplier when off road (e.g. you lose 2% speed each update frame)\nlet skySpeed       = 0.001;                   // background sky layer scroll speed when going around curve (or up hill)\nlet hillSpeed      = 0.002;                   // background hill layer scroll speed when going around curve (or up hill)\nlet treeSpeed      = 0.003;                   // background tree layer scroll speed when going around curve (or up hill)\nlet skyOffset      = 0;                       // current sky scroll offset\nlet hillOffset     = 0;                       // current hill scroll offset\nlet treeOffset     = 0;                       // current tree scroll offset\nlet segments       = [];                      // array of road segments\nlet cars           = [];                      // array of cars on the road\n// let stats          = Game.stats('fps');       // mr.doobs FPS counter\nlet canvas         = Dom.get('canvas');       // our canvas...\nlet ctx            = canvas.getContext('2d'); // ...and its drawing context\nlet GAME_STATES    = ['intro', 'players', 'start', 'game', 'gameover'];\nlet gameState      = 'intro';\nlet background     = null;                    // our background image (loaded below)\nlet sprites        = null;                    // our spritesheet (loaded below)\nlet resolution     = null;                    // scaling factor to provide resolution independence (computed)\nlet roadWidth      = 2000;                    // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth\nlet segmentLength  = 200;                     // length of a single segment\nlet rumbleLength   = 3;                       // number of segments per red/white rumble strip\nlet trackLength    = null;                    // z length of entire track (computed)\nlet lanes          = 3;                       // number of lanes\nlet fieldOfView    = 100;                     // angle (degrees) for field of view\nlet cameraHeight   = 1000;                    // z height of camera\nlet cameraDepth    = null;                    // z distance camera is from screen (computed)\nlet drawDistance   = 150;                     // number of segments to draw\nlet playerX        = 0;                       // player x offset from center of road (-1 to 1 to stay independent of roadWidth)\nlet playerZ        = null;                    // player relative z distance from camera (computed)\nlet fogDensity     = 4;                       // exponential fog density\nlet position       = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)\nlet maxSpeed       = (segmentLength/step) * 1.5;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)\nlet speed          = 0;                       // current speed\nlet accel          = maxSpeed/5;             // acceleration rate - tuned until it 'felt' right\nlet breaking       = -maxSpeed;               // deceleration rate when braking\nlet decel          = -maxSpeed/5;             // 'natural' deceleration rate when neither accelerating, nor braking\nlet offRoadDecel   = -maxSpeed/2;             // off road deceleration is somewhere in between\nlet offRoadLimit   =  maxSpeed/4;             // limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)\nlet totalCars      = 200;                     // total number of cars on the road\nlet currentLapTime = 0;                       // current lap time\nlet lastLapTime    = null;                    // last lap time\n\nlet keyLeft        = false;\nlet keyRight       = false;\nlet keyFaster      = false;\nlet keySlower      = false;\n\nlet hud = {\n  speed:            { value: null, dom: Dom.get('speed_value')            },\n  current_lap_time: { value: null, dom: Dom.get('current_lap_time_value') },\n  // last_lap_time:    { value: null, dom: Dom.get('last_lap_time_value')    },\n  // fast_lap_time:    { value: null, dom: Dom.get('fast_lap_time_value')    }\n}\n\n//=========================================================================\n// UPDATE THE GAME WORLD\n//=========================================================================\n\nfunction update(dt) {\n  var n, car, carW, sprite, spriteW;\n  var playerSegment = findSegment(position+playerZ);\n  var playerW       = SPRITES.PLAYER_STRAIGHT.w * SPRITES.SCALE;\n  var speedPercent  = speed/maxSpeed;\n  var dx            = dt * 2 * speedPercent; // at top speed, should be able to cross from left to right (-1 to 1) in 1 second\n  var startPosition = position;\n\n  updateCars(dt, playerSegment, playerW);\n\n  position = Util.increase(position, dt * speed, trackLength);\n\n  if (keyLeft)\n    playerX = playerX - dx;\n  else if (keyRight)\n    playerX = playerX + dx;\n\n  playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);\n\n  if (keyFaster)\n    speed = Util.accelerate(speed, accel, dt);\n  else if (keySlower)\n    speed = Util.accelerate(speed, breaking, dt);\n  else\n    speed = Util.accelerate(speed, decel, dt);\n\n\n  if ((playerX < -1) || (playerX > 1)) {\n\n    if (speed > offRoadLimit)\n      speed = Util.accelerate(speed, offRoadDecel, dt);\n\n    for(n = 0 ; n < playerSegment.sprites.length ; n++) {\n      sprite  = playerSegment.sprites[n];\n      spriteW = sprite.source.w * SPRITES.SCALE;\n      if (Util.overlap(playerX, playerW, sprite.offset + spriteW/2 * (sprite.offset > 0 ? 1 : -1), spriteW)) {\n        speed = maxSpeed/5;\n        position = Util.increase(playerSegment.p1.world.z, -playerZ, trackLength); // stop in front of sprite (at front of segment)\n        break;\n      }\n    }\n  }\n\n  for(n = 0 ; n < playerSegment.cars.length ; n++) {\n    car  = playerSegment.cars[n];\n    carW = car.sprite.w * SPRITES.SCALE;\n    if (speed > car.speed) {\n      if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {\n        speed    = car.speed * (car.speed/speed);\n        position = Util.increase(car.z, -playerZ, trackLength);\n        break;\n      }\n    }\n  }\n\n  playerX = Util.limit(playerX, -3, 3);     // dont ever let it go too far out of bounds\n  speed   = Util.limit(speed, 0, maxSpeed); // or exceed maxSpeed\n\n  skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * (position-startPosition)/segmentLength, 1);\n  hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * (position-startPosition)/segmentLength, 1);\n  treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * (position-startPosition)/segmentLength, 1);\n\n  if (position > playerZ) {\n    if (currentLapTime && (startPosition < playerZ)) {\n      // lastLapTime    = currentLapTime;\n      // currentLapTime = 0;\n      // if (lastLapTime <= Util.toFloat(Dom.storage.fast_lap_time)) {\n      //   Dom.storage.fast_lap_time = lastLapTime;\n      //   updateHud('fast_lap_time', formatTime(lastLapTime));\n      //   Dom.addClassName('fast_lap_time', 'fastest');\n      //   Dom.addClassName('last_lap_time', 'fastest');\n      // }\n      // else {\n      //   Dom.removeClassName('fast_lap_time', 'fastest');\n      //   Dom.removeClassName('last_lap_time', 'fastest');\n      // }\n      // updateHud('last_lap_time', formatTime(lastLapTime));\n      // Dom.show('last_lap_time');\n    }\n    else {\n      currentLapTime += dt;\n    }\n  }\n\n  updateHud('speed',            5 * Math.round(speed/500));\n  updateHud('current_lap_time', formatTime(currentLapTime));\n}\n\nfunction updateCars(dt, playerSegment, playerW) {\n  var n, car, oldSegment, newSegment;\n  for (n = 0 ; n < cars.length ; n++) {\n    car         = cars[n];\n    oldSegment  = findSegment(car.z);\n    car.offset  = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);\n    car.z       = Util.increase(car.z, dt * car.speed, trackLength);\n    car.percent = Util.percentRemaining(car.z, segmentLength); // useful for interpolation during rendering phase\n    newSegment  = findSegment(car.z);\n    if (oldSegment != newSegment) {\n      index = oldSegment.cars.indexOf(car);\n      oldSegment.cars.splice(index, 1);\n      newSegment.cars.push(car);\n    }\n  }\n}\n\nfunction updateCarOffset(car, carSegment, playerSegment, playerW) {\n  var i, j, dir, segment, otherCar, otherCarW, lookahead = 20, carW = car.sprite.w * SPRITES.SCALE;\n\n  // optimization, dont bother steering around other cars when 'out of sight' of the player\n  if ((carSegment.index - playerSegment.index) > drawDistance) { return 0; }\n\n  for(i = 1 ; i < lookahead ; i++) {\n    segment = segments[(carSegment.index+i)%segments.length];\n\n    if ((segment === playerSegment) && (car.speed > speed) && (Util.overlap(playerX, playerW, car.offset, carW, 1.2))) {\n      if (playerX > 0.5) {\n        dir = -1;\n      } else if (playerX < -0.5) {\n        dir = 1;\n      } else {\n        dir = (car.offset > playerX) ? 1 : -1;\n      }\n\n      return dir * 1/i * (car.speed-speed)/maxSpeed; // the closer the cars (smaller i) and the greated the speed ratio, the larger the offset\n    }\n\n    for(j = 0 ; j < segment.cars.length ; j++) {\n      otherCar  = segment.cars[j];\n      otherCarW = otherCar.sprite.w * SPRITES.SCALE;\n      if ((car.speed > otherCar.speed) && Util.overlap(car.offset, carW, otherCar.offset, otherCarW, 1.2)) {\n        if (otherCar.offset > 0.5) {\n          dir = -1;\n        } else if (otherCar.offset < -0.5) {\n          dir = 1;\n        } else {\n          dir = (car.offset > otherCar.offset) ? 1 : -1;\n        }\n\n        return dir * 1/i * (car.speed-otherCar.speed)/maxSpeed;\n      }\n    }\n  }\n\n  // if no cars ahead, but I have somehow ended up off road, then steer back on\n  if (car.offset < -0.9) {\n    return 0.1;\n  } else if (car.offset > 0.9) {\n    return -0.1;\n  } else {\n    return 0;\n  }\n}\n\n//-------------------------------------------------------------------------\n\nfunction updateHud(key, value) { // accessing DOM can be slow, so only do it if value has changed\n  if (hud[key].value !== value) {\n    hud[key].value = value;\n    Dom.set(hud[key].dom, value);\n  }\n}\n\nfunction formatTime(dt) {\n  let minutes = Math.floor(dt/60);\n  let seconds = Math.floor(dt - (minutes * 60));\n  let tenths  = Math.floor(10 * (dt - Math.floor(dt)));\n  if (minutes > 0) {\n    return minutes + \".\" + (seconds < 10 ? \"0\" : \"\") + seconds + \".\" + tenths;\n  } else {\n    return seconds + \".\" + tenths;\n  }\n}\n\n//=========================================================================\n// RENDER THE GAME WORLD\n//=========================================================================\n\nfunction render() {\n  let baseSegment   = findSegment(position);\n  let basePercent   = Util.percentRemaining(position, segmentLength);\n  let playerSegment = findSegment(position+playerZ);\n  let playerPercent = Util.percentRemaining(position+playerZ, segmentLength);\n  let playerY       = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);\n  let maxy          = height;\n  let x  = 0;\n  let dx = - (baseSegment.curve * basePercent);\n\n  ctx.clearRect(0, 0, width, height);\n\n  Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset,  resolution * skySpeed  * playerY);\n  Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset, resolution * hillSpeed * playerY);\n  Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset, resolution * treeSpeed * playerY);\n\n  let n, i, segment, car, sprite, spriteScale, spriteX, spriteY;\n\n  for (n = 0 ; n < drawDistance ; n++) {\n    segment        = segments[(baseSegment.index + n) % segments.length];\n    segment.looped = segment.index < baseSegment.index;\n    segment.fog    = Util.exponentialFog(n/drawDistance, fogDensity);\n    segment.clip   = maxy;\n\n    Util.project(segment.p1, (playerX * roadWidth) - x,      playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);\n    Util.project(segment.p2, (playerX * roadWidth) - x - dx, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);\n\n    x  = x + dx;\n    dx = dx + segment.curve;\n\n    if ((segment.p1.camera.z <= cameraDepth)         || // behind us\n        (segment.p2.screen.y >= segment.p1.screen.y) || // back face cull\n        (segment.p2.screen.y >= maxy))                  // clip by (already rendered) hill\n      continue;\n\n    Render.segment(ctx, width, lanes,\n                   segment.p1.screen.x,\n                   segment.p1.screen.y,\n                   segment.p1.screen.w,\n                   segment.p2.screen.x,\n                   segment.p2.screen.y,\n                   segment.p2.screen.w,\n                   segment.fog,\n                   segment.color);\n\n    maxy = segment.p1.screen.y;\n  }\n\n  for (n = (drawDistance-1) ; n > 0 ; n--) {\n    segment = segments[(baseSegment.index + n) % segments.length];\n\n    for(i = 0 ; i < segment.cars.length ; i++) {\n      car         = segment.cars[i];\n      sprite      = car.sprite;\n      spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);\n      spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width/2);\n      spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);\n      Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);\n    }\n\n    for(i = 0 ; i < segment.sprites.length ; i++) {\n      sprite      = segment.sprites[i];\n      spriteScale = segment.p1.screen.scale;\n      spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/2);\n      spriteY     = segment.p1.screen.y;\n      Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset < 0 ? -1 : 0), -1, segment.clip);\n    }\n\n    if (segment == playerSegment) {\n      Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,\n        cameraDepth/playerZ, width/2,\n        (height/2) - (cameraDepth/playerZ * Util.interpolate(playerSegment.p1.camera.y, playerSegment.p2.camera.y, playerPercent) * height/2),\n        speed * (keyLeft ? -1 : keyRight ? 1 : 0),\n        playerSegment.p2.world.y - playerSegment.p1.world.y);\n    }\n  }\n}\n\nfunction findSegment(z) {\n  return segments[Math.floor(z/segmentLength) % segments.length]; \n}\n\n//=========================================================================\n// BUILD ROAD GEOMETRY\n//=========================================================================\n\nfunction lastY() { return (segments.length == 0) ? 0 : segments[segments.length-1].p2.world.y; }\n\nfunction addSegment(curve, y) {\n  var n = segments.length;\n  segments.push({\n      index: n,\n         p1: { world: { y: lastY(), z:  n   *segmentLength }, camera: {}, screen: {} },\n         p2: { world: { y: y,       z: (n+1)*segmentLength }, camera: {}, screen: {} },\n      curve: curve,\n    sprites: [],\n       cars: [],\n      color: Math.floor(n/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT\n  });\n}\n\nfunction addSprite(n, sprite, offset) {\n  segments[n].sprites.push({ source: sprite, offset: offset });\n}\n\nfunction addRoad(enter, hold, leave, curve, y) {\n  var startY   = lastY();\n  var endY     = startY + (Util.toInt(y, 0) * segmentLength);\n  var n, total = enter + hold + leave;\n  for(n = 0 ; n < enter ; n++)\n    addSegment(Util.easeIn(0, curve, n/enter), Util.easeInOut(startY, endY, n/total));\n  for(n = 0 ; n < hold  ; n++)\n    addSegment(curve, Util.easeInOut(startY, endY, (enter+n)/total));\n  for(n = 0 ; n < leave ; n++)\n    addSegment(Util.easeInOut(curve, 0, n/leave), Util.easeInOut(startY, endY, (enter+hold+n)/total));\n}\n\nvar ROAD = {\n  LENGTH: { NONE: 0, SHORT:  25, MEDIUM:   50, LONG:  100 },\n  HILL:   { NONE: 0, LOW:    20, MEDIUM:   40, HIGH:   60 },\n  CURVE:  { NONE: 0, EASY:    2, MEDIUM:    4, HARD:    6 }\n};\n\nfunction addStraight(num) {\n  num = num || ROAD.LENGTH.MEDIUM;\n  addRoad(num, num, num, 0, 0);\n}\n\nfunction addHill(num, height) {\n  num    = num    || ROAD.LENGTH.MEDIUM;\n  height = height || ROAD.HILL.MEDIUM;\n  addRoad(num, num, num, 0, height);\n}\n\nfunction addCurve(num, curve, height) {\n  num    = num    || ROAD.LENGTH.MEDIUM;\n  curve  = curve  || ROAD.CURVE.MEDIUM;\n  height = height || ROAD.HILL.NONE;\n  addRoad(num, num, num, curve, height);\n}\n    \nfunction addLowRollingHills(num, height) {\n  num    = num    || ROAD.LENGTH.SHORT;\n  height = height || ROAD.HILL.LOW;\n  addRoad(num, num, num,  0,                height/2);\n  addRoad(num, num, num,  0,               -height);\n  addRoad(num, num, num,  ROAD.CURVE.EASY,  height);\n  addRoad(num, num, num,  0,                0);\n  addRoad(num, num, num, -ROAD.CURVE.EASY,  height/2);\n  addRoad(num, num, num,  0,                0);\n}\n\nfunction addSCurves() {\n  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY,    ROAD.HILL.NONE);\n  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.MEDIUM,  ROAD.HILL.MEDIUM);\n  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.EASY,   -ROAD.HILL.LOW);\n  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY,    ROAD.HILL.MEDIUM);\n  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.MEDIUM, -ROAD.HILL.MEDIUM);\n}\n\nfunction addBumps() {\n  addRoad(10, 10, 10, 0,  5);\n  addRoad(10, 10, 10, 0, -2);\n  addRoad(10, 10, 10, 0, -5);\n  addRoad(10, 10, 10, 0,  8);\n  addRoad(10, 10, 10, 0,  5);\n  addRoad(10, 10, 10, 0, -7);\n  addRoad(10, 10, 10, 0,  5);\n  addRoad(10, 10, 10, 0, -2);\n}\n\nfunction addDownhillToEnd(num) {\n  num = num || 200;\n  addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY()/segmentLength);\n}\n\nfunction resetRoad() {\n  segments = [];\n\n  addStraight(ROAD.LENGTH.SHORT);\n  addLowRollingHills();\n  addSCurves();\n  addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);\n  addBumps();\n  addLowRollingHills();\n  addCurve(ROAD.LENGTH.LONG*2, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);\n  addStraight();\n  addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);\n  addSCurves();\n  addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.MEDIUM, ROAD.HILL.NONE);\n  addHill(ROAD.LENGTH.LONG, ROAD.HILL.HIGH);\n  addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);\n  addBumps();\n  addHill(ROAD.LENGTH.LONG, -ROAD.HILL.MEDIUM);\n  addStraight();\n  addSCurves();\n  addDownhillToEnd();\n\n  resetSprites();\n  resetCars();\n\n  segments[findSegment(playerZ).index + 2].color = COLORS.START;\n  segments[findSegment(playerZ).index + 3].color = COLORS.START;\n  for(var n = 0 ; n < rumbleLength ; n++)\n    segments[segments.length-1-n].color = COLORS.FINISH;\n\n  trackLength = segments.length * segmentLength;\n}\n\nfunction resetSprites() {\n  var n, i;\n\n  // addSprite(20,  SPRITES.BILLBOARD07, -1);\n  // addSprite(40,  SPRITES.BILLBOARD06, -1);\n  // addSprite(60,  SPRITES.BILLBOARD08, -1);\n  // addSprite(80,  SPRITES.BILLBOARD09, -1);\n  // addSprite(100, SPRITES.BILLBOARD01, -1);\n  // addSprite(120, SPRITES.BILLBOARD02, -1);\n  // addSprite(140, SPRITES.BILLBOARD03, -1);\n  // addSprite(160, SPRITES.BILLBOARD04, -1);\n  // addSprite(180, SPRITES.BILLBOARD05, -1);\n\n  // addSprite(240,                  SPRITES.BILLBOARD07, -1.2);\n  // addSprite(240,                  SPRITES.BILLBOARD06,  1.2);\n  // addSprite(segments.length - 25, SPRITES.BILLBOARD07, -1.2);\n  // addSprite(segments.length - 25, SPRITES.BILLBOARD06,  1.2);\n\n  // for(n = 10 ; n < 200 ; n += 4 + Math.floor(n/100)) {\n  //   addSprite(n, SPRITES.PALM_TREE, 0.5 + Math.random()*0.5);\n  //   addSprite(n, SPRITES.PALM_TREE,   1 + Math.random()*2);\n  // }\n\n  // for(n = 250 ; n < 1000 ; n += 5) {\n  //   addSprite(n,     SPRITES.COLUMN, 1.1);\n  //   addSprite(n + Util.randomInt(0,5), SPRITES.TREE1, -1 - (Math.random() * 2));\n  //   addSprite(n + Util.randomInt(0,5), SPRITES.TREE2, -1 - (Math.random() * 2));\n  // }\n\n  // for(n = 200 ; n < segments.length ; n += 3) {\n  //   addSprite(n, Util.randomChoice(SPRITES.PLANTS), Util.randomChoice([1,-1]) * (2 + Math.random() * 5));\n  // }\n\n  // var side, sprite, offset;\n  // for(n = 1000 ; n < (segments.length-50) ; n += 100) {\n  //   side      = Util.randomChoice([1, -1]);\n  //   addSprite(n + Util.randomInt(0, 50), Util.randomChoice(SPRITES.BILLBOARDS), -side);\n  //   for(i = 0 ; i < 20 ; i++) {\n  //     sprite = Util.randomChoice(SPRITES.PLANTS);\n  //     offset = side * (1.5 + Math.random());\n  //     addSprite(n + Util.randomInt(0, 50), sprite, offset);\n  //   }\n      \n  // }\n\n}\n\nfunction resetCars() {\n  cars = [];\n  var n, car, segment, offset, z, sprite, speed;\n  for (var n = 0 ; n < totalCars ; n++) {\n    offset = Math.random() * Util.randomChoice([-0.8, 0.8]);\n    z      = Math.floor(Math.random() * segments.length) * segmentLength;\n    sprite = Util.randomChoice(SPRITES.CARS);\n    speed  = maxSpeed/4 + Math.random() * maxSpeed/(sprite == SPRITES.SEMI ? 4 : 2);\n    car = { offset: offset, z: z, sprite: sprite, speed: speed };\n    segment = findSegment(car.z);\n    segment.cars.push(car);\n    cars.push(car);\n  }\n}\n\n//=========================================================================\n// THE GAME LOOP\n//=========================================================================\n\nlet newGame = new Game();\n\nnewGame.run({\n  canvas: canvas,\n  render: render,\n  update: update,\n  step: step,\n  images: [\"intro\", \"background\", \"sprites\"],\n  keys: [\n    { keys: [KEY.LEFT,  KEY.A], mode: 'down', action: function() { keyLeft   = true;  } },\n    { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function() { keyRight  = true;  } },\n    { keys: [KEY.UP,    KEY.W], mode: 'down', action: function() { keyFaster = true;  } },\n    { keys: [KEY.DOWN,  KEY.S], mode: 'down', action: function() { keySlower = true;  } },\n    { keys: [KEY.LEFT,  KEY.A], mode: 'up',   action: function() { keyLeft   = false; } },\n    { keys: [KEY.RIGHT, KEY.D], mode: 'up',   action: function() { keyRight  = false; } },\n    { keys: [KEY.UP,    KEY.W], mode: 'up',   action: function() { keyFaster = false; } },\n    { keys: [KEY.DOWN,  KEY.S], mode: 'up',   action: function() { keySlower = false; } }\n  ],\n  ready: function(images) {\n    if (gameState === 'intro' || gameState === 'select_player') {\n      background = images[0];\n    } else {\n      background = images[0];\n      sprites    = images[1];\n    }\n    console.log('BACK: ', background);\n    reset();\n    // Dom.storage.fast_lap_time = Dom.storage.fast_lap_time || 180;\n    // updateHud('fast_lap_time', formatTime(Util.toFloat(Dom.storage.fast_lap_time)));\n  }\n});\n\nfunction reset(options) {\n  options       = options || {};\n  canvas.width  = width  = Util.toInt(options.width,          width);\n  canvas.height = height = Util.toInt(options.height,         height);\n  lanes                  = Util.toInt(options.lanes,          lanes);\n  roadWidth              = Util.toInt(options.roadWidth,      roadWidth);\n  cameraHeight           = Util.toInt(options.cameraHeight,   cameraHeight);\n  drawDistance           = Util.toInt(options.drawDistance,   drawDistance);\n  fogDensity             = Util.toInt(options.fogDensity,     fogDensity);\n  fieldOfView            = Util.toInt(options.fieldOfView,    fieldOfView);\n  segmentLength          = Util.toInt(options.segmentLength,  segmentLength);\n  rumbleLength           = Util.toInt(options.rumbleLength,   rumbleLength);\n  cameraDepth            = 1 / Math.tan((fieldOfView/2) * Math.PI/180);\n  playerZ                = (cameraHeight * cameraDepth);\n  resolution             = height/480;\n  refreshTweakUI();\n\n  if ((segments.length==0) || (options.segmentLength) || (options.rumbleLength))\n    resetRoad(); // only rebuild road when necessary\n}\n\n//=========================================================================\n// TWEAK UI HANDLERS\n//=========================================================================\n\n// Dom.on('resolution', 'change', function(ev) {\n//   var w, h, ratio;\n//   switch(ev.target.options[ev.target.selectedIndex].value) {\n//     case 'fine':   w = 1280; h = 960;  ratio=w/width; break;\n//     case 'high':   w = 1024; h = 768;  ratio=w/width; break;\n//     case 'medium': w = 640;  h = 480;  ratio=w/width; break;\n//     case 'low':    w = 480;  h = 360;  ratio=w/width; break;\n//   }\n//   reset({ width: w, height: h })\n//   Dom.blur(ev);\n// });\n\n// Dom.on('lanes',          'change', function(ev) { Dom.blur(ev); reset({ lanes:         ev.target.options[ev.target.selectedIndex].value }); });\n// Dom.on('roadWidth',      'change', function(ev) { Dom.blur(ev); reset({ roadWidth:     Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n// Dom.on('cameraHeight',   'change', function(ev) { Dom.blur(ev); reset({ cameraHeight:  Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n// Dom.on('drawDistance',   'change', function(ev) { Dom.blur(ev); reset({ drawDistance:  Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n// Dom.on('fieldOfView',    'change', function(ev) { Dom.blur(ev); reset({ fieldOfView:   Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n// Dom.on('fogDensity',     'change', function(ev) { Dom.blur(ev); reset({ fogDensity:    Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });\n\nfunction refreshTweakUI() {\n  Dom.get('lanes').selectedIndex = lanes-1;\n  Dom.get('currentRoadWidth').innerHTML      = Dom.get('roadWidth').value      = roadWidth;\n  Dom.get('currentCameraHeight').innerHTML   = Dom.get('cameraHeight').value   = cameraHeight;\n  Dom.get('currentDrawDistance').innerHTML   = Dom.get('drawDistance').value   = drawDistance;\n  Dom.get('currentFieldOfView').innerHTML    = Dom.get('fieldOfView').value    = fieldOfView;\n  Dom.get('currentFogDensity').innerHTML     = Dom.get('fogDensity').value     = fogDensity;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/common.js","//=========================================================================\n// general purpose helpers (mostly math)\n//=========================================================================\n\nconst timestamp = function() { return new Date().getTime(); };\nconst toInt = function(obj, def) { \n  if (obj !== null) { let x = parseInt(obj, 10);\n  if (!isNaN(x)) return x; } return toInt(def, 0);\n};\nconst toFloat = function(obj, def) {\n  if (obj !== null) { let x = parseFloat(obj);\n  if (!isNaN(x)) return x; }\n  return toFloat(def, 0.0);\n};\nconst limit = function(value, min, max) { return Math.max(min, Math.min(value, max)); };\nconst randomInt = function(min, max) { return Math.round(interpolate(min, max, Math.random())); };\nconst randomChoice = function(options) { return options[randomInt(0, options.length-1)]; };\nconst percentRemaining = function(n, total) { return (n%total)/total; };\nconst accelerate = function(v, accel, dt) { return v + (accel * dt);                                        };\nconst interpolate = function(a,b,percent) { return a + (b-a)*percent                                        };\nconst easeIn = function(a,b,percent) { return a + (b-a)*Math.pow(percent,2);                           };\nconst easeOut = function(a,b,percent) { return a + (b-a)*(1-Math.pow(1-percent,2));                     };\nconst easeInOut = function(a,b,percent) { return a + (b-a)*((-Math.cos(percent*Math.PI)/2) + 0.5);        };\nconst exponentialFog = function(distance, density) { return 1 / (Math.pow(Math.E, (distance * distance * density))); };\n\nconst increase = function(start, increment, max) { // with looping\n  let result = start + increment;\n  while (result >= max)\n    result -= max;\n  while (result < 0)\n    result += max;\n  return result;\n};\n\nconst project = function(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {\n  p.camera.x     = (p.world.x || 0) - cameraX;\n  p.camera.y     = (p.world.y || 0) - cameraY;\n  p.camera.z     = (p.world.z || 0) - cameraZ;\n  p.screen.scale = cameraDepth/p.camera.z;\n  p.screen.x     = Math.round((width/2)  + (p.screen.scale * p.camera.x  * width/2));\n  p.screen.y     = Math.round((height/2) - (p.screen.scale * p.camera.y  * height/2));\n  p.screen.w     = Math.round(             (p.screen.scale * roadWidth   * width/2));\n};\n\nconst overlap = function(x1, w1, x2, w2, percent) {\n  let half = (percent || 1)/2;\n  let min1 = x1 - (w1*half);\n  let max1 = x1 + (w1*half);\n  let min2 = x2 - (w2*half);\n  let max2 = x2 + (w2*half);\n  return ! ((max1 < min2) || (min1 > max2));\n};\n\nexport { timestamp, toInt, toFloat, limit, randomInt, randomChoice,\n  percentRemaining, accelerate, interpolate, easeIn, easeOut, easeInOut,\n  exponentialFog, increase, project, overlap };\n\n\n\n// WEBPACK FOOTER //\n// ./app/util.js","//=========================================================================\n// minimalist DOM helpers\n//=========================================================================\n\nclass Dom {\n  constructor() {\n    this.storage = window.localStorage || {};\n  }\n\n  get(id) {\n    return ((id instanceof HTMLElement) || (id === document)) ? id : document.getElementById(id);\n  }\n\n  set(id, html) {\n    this.get(id).innerHTML = html;\n  }\n\n  on(ele, type, fn, capture) {\n    this.get(ele).addEventListener(type, fn, capture);\n  }\n\n  un(ele, type, fn, capture) {\n    this.get(ele).removeEventListener(type, fn, capture);\n  }\n\n  show(ele, type) {\n    this.get(ele).style.display = (type || 'block');\n  }\n\n  blur(ev) {\n    ev.target.blur();\n  }\n\n  addClassName(ele, name) {\n    this.toggleClassName(ele, name, true);\n  }\n\n  removeClassName(ele, name) {\n    this.toggleClassName(ele, name, false);\n  }\n\n  toggleClassName(ele, name, on) {\n    ele = this.get(ele);\n    var classes = ele.className.split(' ');\n    var n = classes.indexOf(name);\n    on = (typeof on == 'undefined') ? (n < 0) : on;\n    if (on && (n < 0))\n      classes.push(name);\n    else if (!on && (n >= 0))\n      classes.splice(n, 1);\n    ele.className = classes.join(' ');\n  }\n}\nlet dom = new Dom();\n\nexport default dom;\n\n\n\n// WEBPACK FOOTER //\n// ./app/dom.js","//=============================================================================\n// RACING GAME CONSTANTS\n//=============================================================================\n\nconst KEY = {\n  LEFT:  37,\n  UP:    38,\n  RIGHT: 39,\n  DOWN:  40,\n  A:     65,\n  D:     68,\n  S:     83,\n  W:     87\n};\n\nconst COLORS = {\n  SKY:  '#72D7EE',\n  TREE: '#005108',\n  FOG:  '#005108',\n  LIGHT:  { road: '#6B6B6B', grass: '#10AA10', rumble: '#555555', lane: '#CCCCCC'  },\n  DARK:   { road: '#696969', grass: '#009A00', rumble: '#BBBBBB'                   },\n  START:  { road: 'white',   grass: 'white',   rumble: 'white'                     },\n  FINISH: { road: 'black',   grass: 'black',   rumble: 'black'                     }\n};\n\nconst BACKGROUND = {\n  HILLS: { x:   5, y:   5, w: 1280, h: 480 },\n  SKY:   { x:   5, y: 495, w: 1280, h: 480 },\n  TREES: { x:   5, y: 985, w: 1280, h: 480 }\n};\n\nconst SPRITES = {\n  PALM_TREE:              { x:    5, y:    5, w:  215, h:  540 },\n  BILLBOARD08:            { x:  230, y:    5, w:  385, h:  265 },\n  TREE1:                  { x:  625, y:    5, w:  360, h:  360 },\n  DEAD_TREE1:             { x:    5, y:  555, w:  135, h:  332 },\n  BILLBOARD09:            { x:  150, y:  555, w:  328, h:  282 },\n  BOULDER3:               { x:  230, y:  280, w:  320, h:  220 },\n  COLUMN:                 { x:  995, y:    5, w:  200, h:  315 },\n  BILLBOARD01:            { x:  625, y:  375, w:  300, h:  170 },\n  BILLBOARD06:            { x:  488, y:  555, w:  298, h:  190 },\n  BILLBOARD05:            { x:    5, y:  897, w:  298, h:  190 },\n  BILLBOARD07:            { x:  313, y:  897, w:  298, h:  190 },\n  BOULDER2:               { x:  621, y:  897, w:  298, h:  140 },\n  TREE2:                  { x: 1205, y:    5, w:  282, h:  295 },\n  BILLBOARD04:            { x: 1205, y:  310, w:  268, h:  170 },\n  DEAD_TREE2:             { x: 1205, y:  490, w:  150, h:  260 },\n  BOULDER1:               { x: 1205, y:  760, w:  168, h:  248 },\n  BUSH1:                  { x:    5, y: 1097, w:  240, h:  155 },\n  CACTUS:                 { x:  929, y:  897, w:  235, h:  118 },\n  BUSH2:                  { x:  255, y: 1097, w:  232, h:  152 },\n  BILLBOARD03:            { x:    5, y: 1262, w:  230, h:  220 },\n  BILLBOARD02:            { x:  245, y: 1262, w:  215, h:  220 },\n  STUMP:                  { x:  995, y:  330, w:  195, h:  140 },\n  SEMI:                   { x: 1365, y:  490, w:  122, h:  144 },\n  TRUCK:                  { x: 1365, y:  644, w:  100, h:   78 },\n  CAR03:                  { x: 1383, y:  760, w:   88, h:   55 },\n  CAR02:                  { x: 1383, y:  825, w:   80, h:   59 },\n  CAR04:                  { x: 1383, y:  894, w:   80, h:   57 },\n  CAR01:                  { x: 1205, y: 1018, w:   80, h:   56 },\n  PLAYER_UPHILL_LEFT:     { x: 1383, y:  961, w:   80, h:   45 },\n  PLAYER_UPHILL_STRAIGHT: { x: 1295, y: 1018, w:   80, h:   45 },\n  PLAYER_UPHILL_RIGHT:    { x: 1385, y: 1018, w:   80, h:   45 },\n  PLAYER_LEFT:            { x:  992, y:  480, w:   90, h:   67 },\n  PLAYER_STRAIGHT:        { x: 1086, y:  470, w:   86, h:   77 },\n  PLAYER_RIGHT:           { x:  992, y:  548, w:   90, h:   67 }\n};\n\nSPRITES.SCALE = 0.3 * (1/SPRITES.PLAYER_STRAIGHT.w) // the reference sprite width should be 1/3rd the (half-)roadWidth\nSPRITES.BILLBOARDS = [SPRITES.BILLBOARD01, SPRITES.BILLBOARD02, SPRITES.BILLBOARD03, SPRITES.BILLBOARD04, SPRITES.BILLBOARD05, SPRITES.BILLBOARD06, SPRITES.BILLBOARD07, SPRITES.BILLBOARD08, SPRITES.BILLBOARD09];\nSPRITES.PLANTS     = [SPRITES.TREE1, SPRITES.TREE2, SPRITES.DEAD_TREE1, SPRITES.DEAD_TREE2, SPRITES.PALM_TREE, SPRITES.BUSH1, SPRITES.BUSH2, SPRITES.CACTUS, SPRITES.STUMP, SPRITES.BOULDER1, SPRITES.BOULDER2, SPRITES.BOULDER3];\nSPRITES.CARS       = [SPRITES.CAR01, SPRITES.CAR02, SPRITES.CAR03, SPRITES.CAR04, SPRITES.SEMI, SPRITES.TRUCK];\n\nexport { KEY, COLORS, BACKGROUND, SPRITES };\n\n\n\n// WEBPACK FOOTER //\n// ./app/constants.js","import Dom from 'dom';\nimport { timestamp } from 'util';\n\n//=========================================================================\n// GAME LOOP helpers\n//=========================================================================\n\nexport default class Game {\n  run(options) {\n    this.loadImages(options.images, (images) => {\n\n      options.ready(images); // tell caller to initialize itself because images are loaded and we're ready to rumble\n\n      this.setKeyListener(options.keys);\n\n      var canvas = options.canvas,    // canvas render target is provided by caller\n          update = options.update,    // method to update game logic is provided by caller\n          render = options.render,    // method to render the game is provided by caller\n          step   = options.step,      // fixed frame step (1/fps) is specified by caller\n          now    = null,\n          last   = timestamp(),\n          dt     = 0,\n          gdt    = 0;\n\n      function frame() {\n        now = timestamp();\n        dt  = Math.min(1, (now - last) / 1000); // using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab\n        gdt = gdt + dt;\n        while (gdt > step) {\n          gdt = gdt - step;\n          update(step);\n        }\n        render();\n        last = now;\n        requestAnimationFrame(frame, canvas);\n      }\n      frame(); // lets get this party started\n      \n      // Game.playMusic();\n    });\n  }\n\n  loadImages(names, callback) { // load multiple images and callback when ALL images have loaded\n    const preloadImage = function (path) {\n      return new Promise(function (resolve, reject) {\n        var image = new Image();\n        image.onload = resolve(image);\n        image.onerror = resolve();\n        image.src = path;\n      });\n    };\n\n    Promise.all(names.map(url => {\n      const imgUrl = `../static/images/${url}.png`;\n      return preloadImage(imgUrl);\n    }))\n    .then(arr => {\n      callback(arr);\n    })\n    .catch(err => {\n      callback(err);\n    });\n  }\n\n  setKeyListener(keys) {\n    var onkey = function(keyCode, mode) {\n      var n, k;\n      for(n = 0 ; n < keys.length ; n++) {\n        k = keys[n];\n        k.mode = k.mode || 'up';\n        if ((k.key == keyCode) || (k.keys && (k.keys.indexOf(keyCode) >= 0))) {\n          if (k.mode == mode) {\n            k.action.call();\n          }\n        }\n      }\n    };\n    Dom.on(document, 'keydown', function(ev) { onkey(ev.keyCode, 'down'); } );\n    Dom.on(document, 'keyup',   function(ev) { onkey(ev.keyCode, 'up');   } );\n  }\n\n  // playMusic: function() {\n  //   var music = Dom.get('music');\n  //   music.loop = true;\n  //   music.volume = 0.05; // shhhh! annoying music!\n  //   music.muted = (Dom.storage.muted === \"true\");\n  //   music.play();\n  //   Dom.toggleClassName('mute', 'on', music.muted);\n  //   Dom.on('mute', 'click', function() {\n  //     Dom.storage.muted = music.muted = !music.muted;\n  //     Dom.toggleClassName('mute', 'on', music.muted);\n  //   });\n  // }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./app/game.js","import { randomChoice } from 'util';\nimport { KEY, COLORS, BACKGROUND, SPRITES } from 'constants';\n\n//=========================================================================\n// canvas rendering helpers\n//=========================================================================\n\nclass Render {\n  polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.lineTo(x3, y3);\n    ctx.lineTo(x4, y4);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  segment(ctx, width, lanes, x1, y1, w1, x2, y2, w2, fog, color) {\n    var r1 = this.rumbleWidth(w1, lanes),\n        r2 = this.rumbleWidth(w2, lanes),\n        l1 = this.laneMarkerWidth(w1, lanes),\n        l2 = this.laneMarkerWidth(w2, lanes),\n        lanew1, lanew2, lanex1, lanex2, lane;\n    \n    ctx.fillStyle = color.grass;\n    ctx.fillRect(0, y2, width, y1 - y2);\n    \n    this.polygon(ctx, x1-w1-r1, y1, x1-w1, y1, x2-w2, y2, x2-w2-r2, y2, color.rumble);\n    this.polygon(ctx, x1+w1+r1, y1, x1+w1, y1, x2+w2, y2, x2+w2+r2, y2, color.rumble);\n    this.polygon(ctx, x1-w1,    y1, x1+w1, y1, x2+w2, y2, x2-w2,    y2, color.road);\n    \n    if (color.lane) {\n      lanew1 = w1*2/lanes;\n      lanew2 = w2*2/lanes;\n      lanex1 = x1 - w1 + lanew1;\n      lanex2 = x2 - w2 + lanew2;\n      for(lane = 1 ; lane < lanes ; lanex1 += lanew1, lanex2 += lanew2, lane++)\n        this.polygon(ctx, lanex1 - l1/2, y1, lanex1 + l1/2, y1, lanex2 + l2/2, y2, lanex2 - l2/2, y2, color.lane);\n    }\n    \n    this.fog(ctx, 0, y1, width, y2-y1, fog);\n  }\n\n  background(ctx, background, width, height, layer, rotation, offset) {\n    rotation = rotation || 0;\n    offset   = offset   || 0;\n\n    var imageW = layer.w/2;\n    var imageH = layer.h;\n\n    var sourceX = layer.x + Math.floor(layer.w * rotation);\n    var sourceY = layer.y\n    var sourceW = Math.min(imageW, layer.x+layer.w-sourceX);\n    var sourceH = imageH;\n    \n    var destX = 0;\n    var destY = offset;\n    var destW = Math.floor(width * (sourceW/imageW));\n    var destH = height;\n\n    console.log('CTX: ', ctx, background);\n\n    ctx.drawImage(background, sourceX, sourceY, sourceW, sourceH, destX, destY, destW, destH);\n    if (sourceW < imageW)\n      ctx.drawImage(background, layer.x, sourceY, imageW-sourceW, sourceH, destW-1, destY, width-destW, destH);\n  }\n\n  sprite(ctx, width, height, resolution, roadWidth, sprites, sprite, scale, destX, destY, offsetX, offsetY, clipY) {\n                   //  scale for projection AND relative to roadWidth (for tweakUI)\n    var destW  = (sprite.w * scale * width/2) * (SPRITES.SCALE * roadWidth);\n    var destH  = (sprite.h * scale * width/2) * (SPRITES.SCALE * roadWidth);\n\n    destX = destX + (destW * (offsetX || 0));\n    destY = destY + (destH * (offsetY || 0));\n\n    // console.log('CTX: ', ctx)\n\n    var clipH = clipY ? Math.max(0, destY+destH-clipY) : 0;\n    if (clipH < destH)\n      ctx.drawImage(sprites, sprite.x, sprite.y, sprite.w, sprite.h - (sprite.h*clipH/destH), destX, destY, destW, destH - clipH);\n\n  }\n\n  player(ctx, width, height, resolution, roadWidth, sprites, speedPercent, scale, destX, destY, steer, updown) {\n    var bounce = (1.5 * Math.random() * speedPercent * resolution) * randomChoice([-1,1]);\n    var sprite;\n    if (steer < 0)\n      sprite = (updown > 0) ? SPRITES.PLAYER_UPHILL_LEFT : SPRITES.PLAYER_LEFT;\n    else if (steer > 0)\n      sprite = (updown > 0) ? SPRITES.PLAYER_UPHILL_RIGHT : SPRITES.PLAYER_RIGHT;\n    else\n      sprite = (updown > 0) ? SPRITES.PLAYER_UPHILL_STRAIGHT : SPRITES.PLAYER_STRAIGHT;\n\n    this.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite, scale, destX, destY + bounce, -0.5, -1);\n  }\n\n  fog(ctx, x, y, width, height, fog) {\n    if (fog < 1) {\n      ctx.globalAlpha = (1-fog)\n      ctx.fillStyle = COLORS.FOG;\n      ctx.fillRect(x, y, width, height);\n      ctx.globalAlpha = 1;\n    }\n  }\n\n  rumbleWidth(projectedRoadWidth, lanes) {\n    return projectedRoadWidth/Math.max(6,  2*lanes);\n  }\n\n  laneMarkerWidth(projectedRoadWidth, lanes) {\n    return projectedRoadWidth/Math.max(32, 8*lanes);\n  }\n}\n\nconst render = new Render();\nexport default render;\n\n\n\n// WEBPACK FOOTER //\n// ./app/render.js"],"sourceRoot":""}